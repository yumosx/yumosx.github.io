<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>yumosx&#39;s 博客 - yumosx&#39;s 博客</title>
	<link rel="stylesheet" href="/static/style.css">
	<link rel="alternate" type="application/rss+xml" href="/feed.xml" title="yumosx&#39;s 博客 RSS Feed">
</head>
<body>
	<header>
		<h1><a href="/">yumosx&#39;s 博客</a></h1>
	</header>
	<main>
		
	<h2>博客文章</h2>
	<ul class="post-list">
	
		<li>
			<a href="/posts/sign.html">如何给 commit sign 一下</a>
			<span class="post-date">2023-11-16</span>
			<p>最近在参加开源项目的时候，其中 Approver 要求我去给我的 commit sign 一下，也就是给对应的 commit 加上一个签名，这种签名有两种方式 Signed-off-by（您提供的这种)：是一文本记录，用于表明责任和许可同意。它很容易被任何人复制和添加。 - GPG 签名（git c...</p>
		</li>
	
		<li>
			<a href="/posts/alembic.html">Alembic 数据库迁移工具</a>
			<span class="post-date">2023-11-15</span>
			<p>Alembic 是一个 Python 环境中的数据库迁移工具，类似于 Go 语言中 GORM 的数据库迁移功能。它是 SQLAlchemy 的迁移工具扩展，用于管理数据库架构变更的版本控制。 在 Alembic 中最简单的命令就是初始化项目： alembic init migrations </p>
		</li>
	
		<li>
			<a href="/posts/iac.html">IaC 基础设施即代码</a>
			<span class="post-date">2023-11-15</span>
			<p>我用一个盖房子的比喻来给你解释“Infrastructure as Code”。 **传统方式（手动盖房）：** </p>
		</li>
	
		<li>
			<a href="/posts/impl.html">Go 代码大全</a>
			<span class="post-date">2023-11-15</span>
			<p>Go 语言关于结构体的字段封装是通过字段命名的大小写来完成的, 当我们 </p>
		</li>
	
		<li>
			<a href="/posts/pym.html">Python 依赖问题</a>
			<span class="post-date">2023-11-15</span>
			<p>在 Python 中，没有像 Go 语言中那样的内置模块依赖管理工具（如 Go Modules）。我们通常使用 uv 或 poetry 来管理项目依赖，这两个工具都基于 Python 的虚拟环境（venv）机制。所谓的 venv，实际上是在项目目录中创建一系列文件夹，用于隔离不同项目的依赖。 当你为...</p>
		</li>
	
		<li>
			<a href="/posts/seata.html">Seata 分布式事务框架</a>
			<span class="post-date">2023-11-15</span>
			<p>seata 这个框架为我们提供了三个核心的组件分别是: 1. Transaction Coordinator (TC) - 事务协调器     这个事务协调器负责维护全局事务的运行状态, 比如prepare, commit和 rollback 2. Transaction Manager (TM) ...</p>
		</li>
	
		<li>
			<a href="/posts/otel-part.html">OTLP 导出器的部分失败问题</a>
			<span class="post-date">2025-9-20</span>
			<p>OTLP 是 opentelemetry 中的协议传输标准，在收集到对应的metrics， trace，log 这些数据之后，我们往往会把对应的数据发送到远端，比如对应的 collector 对于整个数据传输的结果其实是存在三种状态的: 1. 失败状态: 比如因为网络问题出现的失败 2. 部分失败:...</p>
		</li>
	
		<li>
			<a href="/posts/otel-text.html">opentelemetry 中的跨上下文传播</a>
			<span class="post-date">2023-9-20</span>
			<p>在 otel 中有一个非常神奇的接口叫做 TextMapPropagator 这个接口用来在分布式追踪系统用于跨进程传播上下文信息的核心组件。 type TextMapPropagator interface { 	Inject(ctx context.Context, carrier TextMa...</p>
		</li>
	
		<li>
			<a href="/posts/pyproc.html">PyProc 源码分析 (持续更新中)</a>
			<span class="post-date">2025-9-22</span>
			<p>PyProc 的 frame 结构分成了两个部分, 第一个部分是对应的帧头, 第二部是对应的 数据部分, 也就是对应的数据部分，类型下面这样 [header][payload] </p>
		</li>
	
	</ul>

	</main>
	<footer>
		<p>© 2025 yumosx&#39;s 博客</p>
	</footer>
</body>
</html>