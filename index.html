<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>yumosx&#39;s 博客 - yumosx&#39;s 博客</title>
	<link rel="stylesheet" href="/static/style.css">
	<link rel="alternate" type="application/rss+xml" href="/feed.xml" title="yumosx&#39;s 博客 RSS Feed">
</head>
<body>
	<header>
		<h1><a href="/">yumosx&#39;s 博客</a></h1>
	</header>
	<main>
		
	<h2>博客文章</h2>
	<ul class="post-list">
	
		<li>
			<a href="/posts/sign.html">如何给 commit sign 一下</a>
			<span class="post-date">2023-11-16</span>
			<p>最近在参加开源项目的时候，其中 Approver 要求我去给我的 commit sign 一下，也就是给对应的 commit 加上一个签名，这种签名有两种方式 Signed-off-by（您提供的这种)：是一文本记录，用于表明责任和许可同意。它很容易被任何人复制和添加。 - GPG 签名（git c...</p>
		</li>
	
		<li>
			<a href="/posts/impl.html">Go 代码大全</a>
			<span class="post-date">2023-11-15</span>
			<p>在 Go 语言中，与 Java 或 Python 等语言不同，结构体（struct）无需显式声明对某个接口的实现。 例如，在 Java 中我们常会写 class Student implements Person 来明确指定接口实现，这种方式具有一定的优势。 如果采用隐式实现机制，当接口中的方法发生...</p>
		</li>
	
		<li>
			<a href="/posts/pym.html">Python 依赖问题</a>
			<span class="post-date">2023-11-15</span>
			<p>在 Python 中，没有像 Go 语言中那样的内置模块依赖管理工具（如 Go Modules）。我们通常使用 uv 或 poetry 来管理项目依赖，这两个工具都基于 Python 的虚拟环境（venv）机制。所谓的 venv，实际上是在项目目录中创建一系列文件夹，用于隔离不同项目的依赖。 当你为...</p>
		</li>
	
		<li>
			<a href="/posts/otel-part.html">OTLP 导出器的部分失败问题</a>
			<span class="post-date">2025-9-20</span>
			<p>OTLP 是 opentelemetry 中的协议传输标准，在收集到对应的metrics， trace，log 这些数据之后，我们往往会把对应的数据发送到远端，比如对应的 collector 对于整个数据传输的结果其实是存在三种状态的: 1. 失败状态: 比如因为网络问题出现的失败 2. 部分失败:...</p>
		</li>
	
		<li>
			<a href="/posts/otel-text.html">opentelemetry 中的跨上下文传播</a>
			<span class="post-date">2023-9-20</span>
			<p>在 otel 中有一个非常神奇的接口叫做 TextMapPropagator 这个接口用来在分布式追踪系统用于跨进程传播上下文信息的核心组件。 type TextMapPropagator interface { 	Inject(ctx context.Context, carrier TextMa...</p>
		</li>
	
	</ul>

	</main>
	<footer>
		<p>© 2025 yumosx&#39;s 博客</p>
	</footer>
</body>
</html>